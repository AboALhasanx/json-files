[
  {
    "question": "Why is an initializer list generally preferred over assignment inside the constructor body for data-member initialization?",
    "options": [
      "Because it guarantees zero-overhead access specifiers",
      "Because members are constructed directly with their final values, avoiding default construction plus reassignment",
      "Because it automatically inlines all accessor functions",
      "Because it prevents incorrect ordering of member initialization inside the constructor body "
    ],
    "correct_option_id": 1
  },
  {
    "question": "Choosing an array as the primary container for fixed-size records mainly provides which advantage?",
    "options": [
      "Constant-time random access regardless of record position",
      "Automatic memory reallocation when the array exceeds capacity",
      "O(1) insertion at arbitrary positions without shifting elements",
      "The ability to resize the array dynamically at runtime without reallocation "
    ],
    "correct_option_id": 0
  },
  {
    "question": "Marking class data members as private while offering public getters is an example of enforcing which OOP principle?",
    "options": [
      "Polymorphism",
      "Encapsulation",
      "Multiple inheritance",
      "Static binding "
    ],
    "correct_option_id": 1
  },
  {
    "question": "If a class exposes its data members directly without any accessor methods, which of the following is the most immediate risk?",
    "options": [
      "Increased compile-time type checking",
      "Automatic reduction in object size at runtime",
      "Unrestricted external modification leading to inconsistent state",
      "Automatic performance improvement due to fewer abstraction layers "
    ],
    "correct_option_id": 2
  },
  {
    "question": "Assuming an array kept strictly in non-increasing order, inserting a new element with the highest value requires which time complexity in the worst case?",
    "options": [
      "O(log n) if binary search is used first",
      "O(n) to shift necessary elements",
      "O(1) if inserted at the beginning directly",
      "O(n²) if additional sorting is performed "
    ],
    "correct_option_id": 1
  },
  {
    "question": "If a destructor fails to release dynamically allocated memory for a class, the most direct consequence is:",
    "options": [
      "Memory leak persisting for the lifetime of the program",
      "Dangling pointer dereference at a later time",
      "Double-free error during stack unwinding",
      "Significant CPU slowdown due to leaked allocations "
    ],
    "correct_option_id": 0
  },
  {
    "question": "Throwing an `IndexOutOfBounds` exception for an invalid position primarily enforces which software engineering principle?",
    "options": [
      "Lazy evaluation of error conditions",
      "Fail-fast by detecting improper use early",
      "Encapsulation of private data",
      "Deferred error handling for user convenience "
    ],
    "correct_option_id": 1
  },
  {
    "question": "In the add(e) algorithm for a fixed-size sorted array, why do we shift elements from right to left when making room for the new entry?",
    "options": [
      "To minimize the total number of element moves",
      "To avoid overwriting entries that have not yet been processed",
      "To maintain constant-time shifts regardless of position",
      "Because shifting in the opposite direction causes race conditions "
    ],
    "correct_option_id": 1
  },
  {
    "question": "What is the worst-case time complexity of inserting a new element into a descendingly sorted array of length n?",
    "options": [
      "O(1) regardless of position",
      "O(log n) with binary search then insertion",
      "O(n) to shift older elements",
      "O(n log n) if a full resort is triggered "
    ],
    "correct_option_id": 2
  },
  {
    "question": "Why does the algorithm check if the array is full and the new score is not higher than the last entry before proceeding?",
    "options": [
      "To ensure the array remains sorted after insertion",
      "To prevent unnecessary work when the new element cannot be included",
      "To automatically increase the array capacity when needed",
      "To switch to a different algorithm for optimization "
    ],
    "correct_option_id": 1
  },
  {
    "question": "When the array is not full, the algorithm increments numEntries before shifting. What would go wrong if this increment were omitted?",
    "options": [
      "The loop boundary would be incorrect and might overwrite the first element",
      "New entries would always be appended at the end regardless of order",
      "The destructor would fail to free the allocated array properly",
      "The array size would exceed its capacity silently "
    ],
    "correct_option_id": 0
  },
  {
    "question": "Why is it necessary to save the removed element in a temporary variable before shifting array entries?",
    "options": [
      "To prevent the loop from going out of bounds",
      "Because shifting will overwrite the original data at index i",
      "To maintain the sorted order of the remaining elements",
      "Because direct reference would lose the value "
    ],
    "correct_option_id": 1
  },
  {
    "question": "What is the time complexity of removing an element at index i from an array of length n in the worst case?",
    "options": [
      "O(1) for direct removal",
      "O(n) for shifting elements",
      "O(log n) if binary search identifies the index",
      "O(n²) if resorting is required "
    ],
    "correct_option_id": 1
  },
  {
    "question": "If remove(i) does not decrement numEntries, what immediate issue will occur?",
    "options": [
      "Subsequent insertions will overwrite existing entries prematurely",
      "The destructor will fail to free all allocated memory",
      "The loop shifting elements will never terminate",
      "The array capacity will increase unexpectedly "
    ],
    "correct_option_id": 0
  },
  {
    "question": "Throwing an exception for an invalid index inside remove(i) primarily helps with:",
    "options": [
      "Ensuring the array remains sorted",
      "Fail-fast error detection to catch bugs early",
      "Automatically resizing the array to fit the operation",
      "Logging errors for later analysis "
    ],
    "correct_option_id": 1
  },
  {
    "question": "What is the primary operation that the inner loop of insertion sort performs?",
    "options": [
      "Swapping adjacent elements until the current element is in place",
      "Copying larger elements one position to the right to make room",
      "Partitioning the array around a pivot",
      "Merging sorted subarrays "
    ],
    "correct_option_id": 1
  },
  {
    "question": "What is the worst-case time complexity of insertion sort on an array of length n?",
    "options": [
      "O(n) if the array is nearly sorted",
      "O(n log n) with optimization",
      "O(n²) in the worst case",
      "O(n!) with deep recursion "
    ],
    "correct_option_id": 2
  },
  {
    "question": "In which scenario does insertion sort run in linear time O(n)?",
    "options": [
      "When the array is already sorted",
      "When the array is in reverse order",
      "When all elements are identical",
      "When the array size is prime "
    ],
    "correct_option_id": 0
  },
  {
    "question": "Why is insertion sort considered adaptive?",
    "options": [
      "Because it uses extra memory proportional to input size",
      "Because it shifts fewer elements when the input is nearly sorted",
      "Because it divides the array recursively",
      "Because it runs in parallel on multiple cores "
    ],
    "correct_option_id": 1
  },
  {
    "question": "Why is it recommended to use symbolic constants for array dimensions?",
    "options": [
      "To allow dynamic resizing at runtime",
      "To make the code clearer and easier to maintain",
      "To reduce compilation time significantly",
      "To enforce strict memory limits "
    ],
    "correct_option_id": 1
  },
  {
    "question": "If `const int N_DAYS = 7; const int N_HOURS = 24; int schedule[N_DAYS][N_HOURS];` is declared, what is the type of `schedule`?",
    "options": [
      "Pointer to pointer of int",
      "Two-dimensional int array of size 7×24",
      "Array of 24 arrays of 7 ints",
      "Dynamic pointer to int "
    ],
    "correct_option_id": 1
  },
  {
    "question": "In a singly linked list, what does the 'next' pointer in each node represent?",
    "options": [
      "A link to the previous node",
      "A link to the next node",
      "The data stored in the node",
      "The index of the node in the list "
    ],
    "correct_option_id": 1
  },
  {
    "question": "Which node in a singly linked list is identified by having its 'next' pointer equal to null?",
    "options": [
      "Head node",
      "Middle node",
      "Tail node",
      "Sentinel node "
    ],
    "correct_option_id": 2
  },
  {
    "question": "What term describes the process of moving from one node to the next by following 'next' pointers?",
    "options": [
      "Index hopping",
      "Link hopping",
      "Memory hopping",
      "Node traversal "
    ],
    "correct_option_id": 1
  },
  {
    "question": "Unlike a fixed-size array, a singly linked list can be resized at runtime because:",
    "options": [
      "Its nodes are stored contiguously in memory",
      "It uses a dynamic array internally",
      "You can add or remove nodes without shifting all elements",
      "It preallocates extra nodes for growth "
    ],
    "correct_option_id": 2
  },
  {
    "question": "In a singly linked list implementation, what does a head pointer value of NULL signify?",
    "options": [
      "The list is empty",
      "The list has one element",
      "The list is full",
      "The list is circular "
    ],
    "correct_option_id": 0
  },
  {
    "question": "What is the time complexity of adding an element to the front of a singly linked list?",
    "options": [
      "O(n) to traverse to the end",
      "O(log n) with balanced splitting",
      "O(1) by adjusting the head pointer",
      "O(n²) if reallocation occurs "
    ],
    "correct_option_id": 2
  },
  {
    "question": "Which sequence of steps correctly describes removing the first node from a singly linked list?",
    "options": [
      "Save head in temp, head = head->next, delete temp",
      "Delete head, then set head to temp->next",
      "head = head->next, delete head",
      "Save head->next, delete head, then set head to saved "
    ],
    "correct_option_id": 0
  },
  {
    "question": "In the node definition `class StringNode { string elem; StringNode* next; };`, what is the role of the `next` pointer?",
    "options": [
      "It stores the data element",
      "It points to the next node in the list",
      "It indicates the end of the list",
      "It tracks the element’s index "
    ],
    "correct_option_id": 1
  },
  {
    "question": "What must the destructor of a singly linked list do to avoid memory leaks?",
    "options": [
      "Repeatedly call removeFront() until the list is empty",
      "Just set head to NULL",
      "Only delete the head pointer",
      "Rely on OS to reclaim memory on exit "
    ],
    "correct_option_id": 0
  },
  {
    "question": "What ensures no memory leaks in the destructor of `SLinkedList<E>`?",
    "options": [
      "Calling delete head; once",
      "Iteratively calling removeFront() until the list is empty",
      "Setting head to NULL without deletion",
      "Relying on garbage collection "
    ],
    "correct_option_id": 1
  },
  {
    "question": "What is the purpose of the header and trailer sentinels in a doubly linked list?",
    "options": [
      "To store user data at the ends of the list",
      "To simplify edge-case code by marking list boundaries",
      "To improve memory allocation speed",
      "To act as backup data nodes "
    ],
    "correct_option_id": 1
  },
  {
    "question": "How can one check if a doubly linked list (with sentinels) is empty?",
    "options": [
      "header->next == trailer",
      "header->prev == trailer",
      "trailer->next == header",
      "trailer->prev == header "
    ],
    "correct_option_id": 0
  },
  {
    "question": "Which advantage do doubly linked lists have over singly linked lists?",
    "options": [
      "They use less memory per node",
      "They allow efficient removal from any position if you have a pointer to the node",
      "They avoid the need for sentinels",
      "They automatically sort elements "
    ],
    "correct_option_id": 1
  },
  {
    "question": "Reversing a doubly linked list by copying elements into a temporary list and back results in what overall time complexity?",
    "options": [
      "O(n) for a single pass",
      "O(n²) because of nested operations",
      "O(log n) with divide-and-conquer",
      "O(1) if pointers are swapped "
    ],
    "correct_option_id": 0
  },
  {
    "question": "During list reversal, inserting each extracted element from the original list to the front of the temporary list ensures that:",
    "options": [
      "The relative order of elements is preserved",
      "The last element of the original list becomes the first in the temporary list",
      "The list remains sorted",
      "No additional memory is used "
    ],
    "correct_option_id": 1
  },
  {
    "question": "What distinguishes the base case in a recursive function?",
    "options": [
      "It calls the function again with a smaller argument",
      "It returns a non-recursive value without further self-calls",
      "It throws an exception when a condition is met",
      "It uses tail recursion optimization "
    ],
    "correct_option_id": 1
  },
  {
    "question": "In a recursion trace, each arrow pointing inward (→) represents:",
    "options": [
      "A return from a function call",
      "A new recursive function call",
      "A loop iteration",
      "A tail-call optimization "
    ],
    "correct_option_id": 1
  },
  {
    "question": "For `recursiveFactorial(n)`, what is the time complexity in terms of `n`?",
    "options": [
      "O(n!) due to factorial growth",
      "O(n) each call reduces n by one",
      "O(log n) with divide-and-conquer",
      "O(2^n) if overlapping calls occur "
    ],
    "correct_option_id": 1
  },
  {
    "question": "Why does a recursive function always terminate if its argument strictly decreases and a base case is defined?",
    "options": [
      "Because C++ enforces a maximum recursion depth",
      "Because eventually the argument reaches the base case and no further self-calls occur",
      "Because the compiler optimizes tail calls automatically",
      "Because the call stack resets periodically "
    ],
    "correct_option_id": 1
  },
  {
    "question": "In a linear recursive function summing an array of length n, how many total calls to the recursive function are made (including the initial call)?",
    "options": [
      "n calls—one per element",
      "n+1 calls to handle the base case",
      "2n calls due to overlapping calls",
      "n−1 calls excluding the base "
    ],
    "correct_option_id": 0
  },
  {
    "question": "Which of the following correctly describes the base case for the recursive array-sum algorithm LinearSum(A,n)?",
    "options": [
      "n == 0: return 0",
      "n == 1: return A[0]",
      "n ≤ 1: return 1",
      "n < 0: throw error "
    ],
    "correct_option_id": 1
  },
  {
    "question": "Which feature distinguishes a tail-recursive function from a general recursive one?",
    "options": [
      "It makes at most one recursive call per invocation",
      "Its recursive call is the very last operation in the function",
      "It uses only constant extra memory",
      "It never calls itself indirectly "
    ],
    "correct_option_id": 1
  },
  {
    "question": "What is the worst-case additional space (call-stack depth) used by the linear recursive sum of n elements?",
    "options": [
      "O(1) independent of n",
      "O(log n) if optimized",
      "O(n) one frame per element",
      "O(n^2) due to nested calls "
    ],
    "correct_option_id": 2
  },
  {
    "question": "What characterizes a binary recursive algorithm?",
    "options": [
      "It makes exactly one recursive call per invocation",
      "It makes two recursive calls per invocation",
      "It alternates between recursion and iteration",
      "It uses a binary search internally "
    ],
    "correct_option_id": 1
  },
  {
    "question": "Assuming n is a power of two, what is the depth of the recursion tree for the BinarySum algorithm on an array of length n?",
    "options": [
      "O(n) if balanced poorly",
      "O(log n) dividing the array in half each time",
      "O(n log n) due to merging",
      "O(1) because depth is constant "
    ],
    "correct_option_id": 1
  },
  {
    "question": "In the BinarySum algorithm, why is the overall running time still O(n) despite binary recursion?",
    "options": [
      "Because each level of recursion processes disjoint halves totaling n elements",
      "Because the base case is reached in constant time",
      "Because the algorithm uses tail recursion",
      "Because overlapping calls cancel out "
    ],
    "correct_option_id": 0
  },
  {
    "question": "What type of recursion is used when a function makes more than two recursive calls per invocation?",
    "options": [
      "Linear recursion",
      "Binary recursion",
      "Multiple recursion",
      "Mutual recursion "
    ],
    "correct_option_id": 2
  },
  {
    "question": "After returning from the recursive call PuzzleSolve(k-1, S, U), why is e added back to U?",
    "options": [
      "To test e in different positions for other permutations",
      "To maintain sorted order of U",
      "To avoid memory leaks",
      "To free memory used by e "
    ],
    "correct_option_id": 0
  }
]
