[
  {
    "question": "1. Why is an initializer list generally preferred over assignment inside the constructor body for data-member initialization?",
    "options": [
      "A. Because it guarantees zero-overhead access specifiers",
      "B. Because members are constructed directly with their final values, avoiding default construction plus reassignment",
      "C. Because it automatically inlines all accessor functions"
    ],
    "correct_option_id": 1
  },
  {
    "question": "2. Choosing an array as the primary container for fixed-size records mainly provides which advantage?",
    "options": [
      "A. Constant-time random access regardless of record position",
      "B. Automatic memory reallocation when the array exceeds capacity",
      "C. O(1) insertion at arbitrary positions without shifting elements"
    ],
    "correct_option_id": 0
  },
  {
    "question": "3. Marking class data members as private while offering public getters is an example of enforcing which OOP principle?",
    "options": [
      "A. Polymorphism",
      "B. Encapsulation",
      "C. Multiple inheritance"
    ],
    "correct_option_id": 1
  },
  {
    "question": "4. If a class exposes its data members directly without any accessor methods, which of the following is the most immediate risk?",
    "options": [
      "A. Increased compile-time type checking",
      "B. Automatic reduction in object size at runtime",
      "C. Unrestricted external modification leading to inconsistent state"
    ],
    "correct_option_id": 2
  },
  {
    "question": "5. Which delete form must be used to properly deallocate memory that was obtained with `new Type[n]` in C++?",
    "options": [
      "A. delete pointer;",
      "B. delete[] pointer;",
      "C. free(pointer);"
    ],
    "correct_option_id": 1
  },
  {
    "question": "6. Assuming an array kept strictly in non-increasing order, inserting a new element with the highest value requires which time complexity in the worst case?",
    "options": [
      "A. O(log n)",
      "B. O(n)",
      "C. O(1)"
    ],
    "correct_option_id": 2
  },
  {
    "question": "7. If a destructor fails to release dynamically allocated memory for a class, the most direct consequence is:",
    "options": [
      "A. Memory leak persisting for the lifetime of the program",
      "B. Dangling pointer dereference",
      "C. Double-free error during stack unwinding"
    ],
    "correct_option_id": 0
  },
  {
    "question": "8. Throwing an `IndexOutOfBounds` exception for an invalid position primarily enforces which software engineering principle?",
    "options": [
      "A. Lazy evaluation of error conditions",
      "B. Fail-fast by detecting improper use early",
      "C. Encapsulation of private data"
    ],
    "correct_option_id": 1
  },
  {
    "question": "9. In the add(e) algorithm for a fixed-size sorted array, why do we shift elements from right to left when making room for the new entry?",
    "options": [
      "A. To minimize the total number of element moves",
      "B. To avoid overwriting entries that have not yet been processed",
      "C. To maintain constant-time shifts regardless of position"
    ],
    "correct_option_id": 1
  },
  {
    "question": "10. What is the worst-case time complexity of inserting a new element into a descendingly sorted array of length n?",
    "options": [
      "A. O(1)",
      "B. O(log n)",
      "C. O(n)"
    ],
    "correct_option_id": 2
  },
  {
    "question": "11. Why does the algorithm check if the array is full and the new score is not higher than the last entry before proceeding?",
    "options": [
      "A. To ensure the array remains sorted after insertion",
      "B. To prevent unnecessary work when the new element cannot be included",
      "C. To automatically increase the array capacity when needed"
    ],
    "correct_option_id": 1
  },
  {
    "question": "12. When the array is not full, the algorithm increments numEntries before shifting. What would go wrong if this increment were omitted?",
    "options": [
      "A. The loop boundary would be incorrect and might overwrite the first element",
      "B. New entries would always be appended at the end rather than inserted in order",
      "C. The destructor would fail to free the allocated array properly"
    ],
    "correct_option_id": 0
  },
  {
    "question": "13. Why is it necessary to save the removed element in a temporary variable before shifting array entries?",
    "options": [
      "A. To prevent the loop from going out of bounds",
      "B. Because shifting will overwrite the original data at index i",
      "C. To maintain the sorted order of the remaining elements"
    ],
    "correct_option_id": 1
  },
  {
    "question": "14. What is the time complexity of removing an element at index i from an array of length n in the worst case?",
    "options": [
      "A. O(1)",
      "B. O(n)",
      "C. O(log n)"
    ],
    "correct_option_id": 1
  },
  {
    "question": "15. If remove(i) does not decrement numEntries, what immediate issue will occur?",
    "options": [
      "A. Subsequent insertions will overwrite existing entries prematurely",
      "B. The destructor will fail to free all allocated memory",
      "C. The loop shifting elements will never terminate"
    ],
    "correct_option_id": 0
  },
  {
    "question": "16. Throwing an exception for an invalid index inside remove(i) primarily helps with:",
    "options": [
      "A. Ensuring the array remains sorted",
      "B. Fail-fast error detection to catch bugs early",
      "C. Automatically resizing the array to fit the operation"
    ],
    "correct_option_id": 1
  },
  {
    "question": "17. What is the primary operation that the inner loop of insertion sort performs?",
    "options": [
      "A. Swapping adjacent elements until the current element is in place",
      "B. Copying larger elements one position to the right to make room",
      "C. Partitioning the array around a pivot"
    ],
    "correct_option_id": 1
  },
  {
    "question": "18. What is the worst-case time complexity of insertion sort on an array of length n?",
    "options": [
      "A. O(n)",
      "B. O(n log n)",
      "C. O(n²)"
    ],
    "correct_option_id": 2
  },
  {
    "question": "19. In which scenario does insertion sort run in linear time O(n)?",
    "options": [
      "A. When the array is already sorted",
      "B. When the array is in reverse order",
      "C. When all elements are identical"
    ],
    "correct_option_id": 0
  },
  {
    "question": "20. Why is insertion sort considered adaptive?",
    "options": [
      "A. Because it uses extra memory proportional to input size",
      "B. Because it shifts fewer elements when the input is nearly sorted",
      "C. Because it divides the array recursively"
    ],
    "correct_option_id": 1
  },
  {
    "question": "21. How do you declare a two-dimensional array with R rows and C columns in C++?",
    "options": [
      "A. int M[C][R];",
      "B. int M[R][C];",
      "C. int M[R,C];"
    ],
    "correct_option_id": 1
  },
  {
    "question": "22. Given `int M[8][10];`, what does `M[3][5]` refer to?",
    "options": [
      "A. Row 5, Column 3 element",
      "B. Row 3, Column 5 element",
      "C. A pointer to the entire 4th row"
    ],
    "correct_option_id": 1
  },
  {
    "question": "23. Why is it recommended to use symbolic constants for array dimensions?",
    "options": [
      "A. To allow dynamic resizing at runtime",
      "B. To make the code clearer and easier to maintain",
      "C. To reduce compilation time"
    ],
    "correct_option_id": 1
  },
  {
    "question": "24. If `const int N_DAYS = 7; const int N_HOURS = 24; int schedule[N_DAYS][N_HOURS];` is declared, what is the type of `schedule`?",
    "options": [
      "A. Pointer to pointer of int",
      "B. 7*24 two-dimensional int array",
      "C. Array of 24 arrays of 7 ints"
    ],
    "correct_option_id": 1
  },
  {
    "question": "25. When dynamically allocating an n×m integer matrix as an array of arrays in C++, what is the correct type of the variable M?",
    "options": [
      "A. int* M;",
      "B. int** M;",
      "C. vector<vector<int>> M;"
    ],
    "correct_option_id": 1
  },
  {
    "question": "26. Which sequence correctly allocates and then deallocates a dynamic n×m int matrix using new/delete?",
    "options": [
      "A. M = new int[n][m]; … delete[] M;",
      "B. M = new int*[n]; for each i: M[i] = new int[m]; … for each i: delete[] M[i]; delete[] M;",
      "C. M = new int[n*m]; … delete M;"
    ],
    "correct_option_id": 1
  },
  {
    "question": "27. Why is using `vector<vector<int>> M(n, vector<int>(m));` preferred over manual new/delete for a dynamic matrix?",
    "options": [
      "A. It compiles faster",
      "B. It automatically manages memory and avoids explicit delete[] loops",
      "C. It uses less memory at runtime"
    ],
    "correct_option_id": 1
  },
  {
    "question": "28. After allocating a matrix with `int** M = new int*[n];` and rows via `M[i] = new int[m];`, what must you do to correctly free all memory?",
    "options": [
      "A. delete M; delete[] M[i] for each i;",
      "B. delete[] M; delete[] M[i] for each i;",
      "C. delete[] M[i] for each i; then delete[] M;"
    ],
    "correct_option_id": 2
  },
  {
    "question": "29. In a singly linked list, what does the 'next' pointer in each node represent?",
    "options": [
      "A. A link to the previous node",
      "B. A link to the next node",
      "C. The data stored in the node"
    ],
    "correct_option_id": 1
  },
  {
    "question": "30. Which node in a singly linked list is identified by having its 'next' pointer equal to null?",
    "options": [
      "A. Head node",
      "B. Middle node",
      "C. Tail node"
    ],
    "correct_option_id": 2
  },
  {
    "question": "31. What term describes the process of moving from one node to the next by following 'next' pointers?",
    "options": [
      "A. Index hopping",
      "B. Link hopping",
      "C. Memory hopping"
    ],
    "correct_option_id": 1
  },
  {
    "question": "32. Unlike a fixed-size array, a singly linked list can be resized at runtime because:",
    "options": [
      "A. Its nodes are stored contiguously in memory",
      "B. It uses a dynamic array internally",
      "C. You can add or remove nodes without shifting all elements"
    ],
    "correct_option_id": 2
  },
  {
    "question": "33. In a singly linked list implementation, what does a head pointer value of NULL signify?",
    "options": [
      "A. The list is empty",
      "B. The list has one element",
      "C. The list is full"
    ],
    "correct_option_id": 0
  },
  {
    "question": "34. What is the time complexity of adding an element to the front of a singly linked list?",
    "options": [
      "A. O(n)",
      "B. O(log n)",
      "C. O(1)"
    ],
    "correct_option_id": 2
  },
  {
    "question": "35. Which sequence of steps correctly describes removing the first node from a singly linked list?",
    "options": [
      "A. Save head in a temp, head = head->next, delete temp",
      "B. Delete head, then save head->next, head = temp",
      "C. head = head->next, delete head"
    ],
    "correct_option_id": 0
  },
  {
    "question": "36. In the node definition `class StringNode { string elem; StringNode* next; };`, what is the role of the `next` pointer?",
    "options": [
      "A. It stores the data element",
      "B. It points to the next node in the list",
      "C. It indicates the end of the list"
    ],
    "correct_option_id": 1
  },
  {
    "question": "37. What must the destructor of a singly linked list do to avoid memory leaks?",
    "options": [
      "A. Repeatedly call removeFront() until the list is empty",
      "B. Just set head to NULL",
      "C. Only delete the head pointer"
    ],
    "correct_option_id": 0
  },
  {
    "question": "38. What does the template parameter `<E>` represent in `class SLinkedList<E>`?",
    "options": [
      "A. The maximum number of elements",
      "B. The type of elements stored in the list",
      "C. The memory allocation strategy"
    ],
    "correct_option_id": 1
  },
  {
    "question": "39. Which statement correctly creates a generic singly linked list of integers?",
    "options": [
      "A. SLinkedList<int> list;",
      "B. SLinkedList list<int>;",
      "C. SLinkedList<E> list<int>;"
    ],
    "correct_option_id": 0
  },
  {
    "question": "40. In the `addFront` method of `SLinkedList<E>`, why do we set `v->next = head` before `head = v`?",
    "options": [
      "A. To free the old head node",
      "B. To link the new node to the existing list",
      "C. To delete previous nodes"
    ],
    "correct_option_id": 1
  },
  {
    "question": "41. What ensures no memory leaks in the destructor of `SLinkedList<E>`?",
    "options": [
      "A. Calling `delete head;` once",
      "B. Iteratively calling `removeFront()` until the list is empty",
      "C. Setting head to NULL without deletion"
    ],
    "correct_option_id": 1
  },
  {
    "question": "42. Why must each definition be prefaced by `template <typename E>` when implementing `SLinkedList<E>` methods?",
    "options": [
      "A. To specify exception handling",
      "B. To instantiate the template for each type parameter",
      "C. To optimize memory usage"
    ],
    "correct_option_id": 1
  },
  {
    "question": "43. What is the purpose of the header and trailer sentinels in a doubly linked list?",
    "options": [
      "A. To store user data at the ends of the list",
      "B. To simplify edge-case code by marking list boundaries",
      "C. To improve memory allocation speed"
    ],
    "correct_option_id": 1
  },
  {
    "question": "44. When inserting a new node z immediately after node v, which pointer update must happen last to maintain list integrity?",
    "options": [
      "A. z->next = v->next;",
      "B. v->next = z;",
      "C. z->prev = v;"
    ],
    "correct_option_id": 1
  },
  {
    "question": "45. In the `remove(DNode* v)` utility, after unlinking v, which action must follow to prevent a memory leak?",
    "options": [
      "A. Delete the header sentinel",
      "B. Delete the trailer sentinel",
      "C. Delete node v"
    ],
    "correct_option_id": 2
  },
  {
    "question": "46. How can one check if a doubly linked list (with sentinels) is empty?",
    "options": [
      "A. header->next == trailer",
      "B. header->prev == trailer",
      "C. trailer->next == header"
    ],
    "correct_option_id": 0
  },
  {
    "question": "47. Which advantage do doubly linked lists have over singly linked lists?",
    "options": [
      "A. They use less memory per node",
      "B. They allow efficient removal from any position if you have a pointer to the node",
      "C. They avoid the need for sentinels"
    ],
    "correct_option_id": 1
  },
  {
    "question": "48. In a circularly linked list with a cursor, the element returned by `back()` is:",
    "options": [
      "A. The element at the cursor node",
      "B. The element immediately after the cursor node",
      "C. The element immediately before the cursor node"
    ],
    "correct_option_id": 0
  },
  {
    "question": "49. Which pointer update is required when adding a new node after the cursor in a nonempty circular list?",
    "options": [
      "A. newNode->next = cursor->next;",
      "B. cursor->next = newNode->next;",
      "C. cursor->next = cursor;"
    ],
    "correct_option_id": 0
  },
  {
    "question": "50. What must the `remove()` operation do when the list contains only one node?",
    "options": [
      "A. Set cursor->next = cursor",
      "B. Delete the node and set cursor = NULL",
      "C. Throw an exception"
    ],
    "correct_option_id": 1
  },
  {
    "question": "51. Reversing a doubly linked list by copying elements into a temporary list and back results in what overall time complexity?",
    "options": [
      "A. O(n)",
      "B. O(n²)",
      "C. O(log n)"
    ],
    "correct_option_id": 1
  },
  {
    "question": "52. During list reversal, inserting each extracted element from the original list to the front of the temporary list ensures that:",
    "options": [
      "A. The relative order of elements is preserved",
      "B. The last element of the original list becomes the first in the temporary list",
      "C. The list remains sorted"
    ],
    "correct_option_id": 1
  },
  {
    "question": "53. What distinguishes the base case in a recursive function?",
    "options": [
      "A. It calls the function again with a smaller argument",
      "B. It returns a non-recursive value without further self-calls",
      "C. It throws an exception when a condition is met"
    ],
    "correct_option_id": 1
  },
  {
    "question": "54. In a recursion trace, each arrow pointing inward (→) represents:",
    "options": [
      "A. A return from a function call",
      "B. A new recursive function call",
      "C. A loop iteration"
    ],
    "correct_option_id": 1
  },
  {
    "question": "55. For `recursiveFactorial(n)`, what is the time complexity in terms of `n`?",
    "options": [
      "A. O(n!)",
      "B. O(n)",
      "C. O(log n)"
    ],
    "correct_option_id": 1
  },
  {
    "question": "56. Which pattern best describes the recursive drawing of ticks between inch marks in the ruler example?",
    "options": [
      "A. drawTicks(L) calls drawTicks(L+1) once",
      "B. drawTicks(L) performs two calls to drawTicks(L-1) around a central action",
      "C. drawTicks(L) uses an iterative for-loop to simulate recursion"
    ],
    "correct_option_id": 1
  },
  {
    "question": "57. Why does a recursive function always terminate if its argument strictly decreases and a base case is defined?",
    "options": [
      "A. Because C++ enforces a maximum recursion depth",
      "B. Because eventually the argument reaches the base case and no further self-calls occur",
      "C. Because the compiler optimizes tail calls automatically"
    ],
    "correct_option_id": 1
  },
  {
    "question": "58. In a linear recursive function summing an array of length n, how many total calls to the recursive function are made (including the initial call)?",
    "options": [
      "A. n",
      "B. n+1",
      "C. 2n",
      "D. n−1"
    ],
    "correct_option_id": 0
  },
  {
    "question": "59. Which of the following correctly describes the base case for the recursive array-sum algorithm LinearSum(A,n)?",
    "options": [
      "A. n == 0: return 0",
      "B. n == 1: return A[0]",
      "C. n ≤ 1: return 1",
      "D. n < 0: throw error"
    ],
    "correct_option_id": 1
  },
  {
    "question": "60. Consider the recursive array-reversal algorithm ReverseArray(A,i,j). What condition signals that the recursion should stop?",
    "options": [
      "A. i == j",
      "B. i > j",
      "C. either i >= j",
      "D. either i == j or i+1 == j"
    ],
    "correct_option_id": 2
  },
  {
    "question": "61. Which feature distinguishes a tail-recursive function from a general recursive one?",
    "options": [
      "A. It makes at most one recursive call per invocation",
      "B. Its recursive call is the very last operation in the function",
      "C. It uses only constant amount of extra memory",
      "D. It never calls itself indirectly"
    ],
    "correct_option_id": 1
  },
  {
    "question": "62. What is the worst-case additional space (call-stack depth) used by the linear recursive sum of n elements?",
    "options": [
      "A. O(1)",
      "B. O(log n)",
      "C. O(n)",
      "D. O(n^2)"
    ],
    "correct_option_id": 2
  },
  {
    "question": "63. What characterizes a binary recursive algorithm?",
    "options": [
      "A. It makes exactly one recursive call per invocation",
      "B. It makes two recursive calls per invocation",
      "C. It alternates between recursion and iteration"
    ],
    "correct_option_id": 1
  },
  {
    "question": "64. Assuming n is a power of two, what is the depth of the recursion tree for the BinarySum algorithm on an array of length n?",
    "options": [
      "A. O(n)",
      "B. O(log n)",
      "C. O(n log n)"
    ],
    "correct_option_id": 1
  },
  {
    "question": "65. Why does the naive binary recursion for Fibonacci (BinaryFib) exhibit exponential time complexity?",
    "options": [
      "A. Because each call makes two overlapping recursive calls",
      "B. Because it uses a loop inside the recursive function",
      "C. Because it allocates a new array on each call"
    ],
    "correct_option_id": 0
  },
  {
    "question": "66. How does the linear recursive Fibonacci algorithm (LinearFibonacci) achieve O(k) calls instead of exponential calls?",
    "options": [
      "A. By caching previous results in a table",
      "B. By returning a pair (Fk, Fk-1) on each call, reducing overlap",
      "C. By using tail recursion optimization"
    ],
    "correct_option_id": 1
  },
  {
    "question": "67. In the BinarySum algorithm, why is the overall running time still O(n) despite binary recursion?",
    "options": [
      "A. Because each level of recursion processes disjoint halves totaling n elements",
      "B. Because the base case is reached in constant time",
      "C. Because the algorithm uses tail recursion"
    ],
    "correct_option_id": 0
  },
  {
    "question": "68. What type of recursion is used when a function makes more than two recursive calls per invocation?",
    "options": [
      "A. Linear recursion",
      "B. Binary recursion",
      "C. Multiple recursion"
    ],
    "correct_option_id": 2
  },
  {
    "question": "69. In the PuzzleSolve algorithm, why is an element e removed from set U before the recursive call?",
    "options": [
      "A. To free memory for e",
      "B. To prevent reusing e in the same configuration",
      "C. To sort the set U"
    ],
    "correct_option_id": 1
  },
  {
    "question": "70. What does PuzzleSolve(k, S, U) enumerate when U has n elements?",
    "options": [
      "A. All subsets of size k from U regardless of order",
      "B. All ordered sequences of length k from U without repetition",
      "C. All possible partitions of U into k parts"
    ],
    "correct_option_id": 1
  },
  {
    "question": "71. What is the total number of recursive calls (including initial) made by PuzzleSolve(3, S, {a,b,c})?",
    "options": [
      "A. 6",
      "B. 9",
      "C. 11"
    ],
    "correct_option_id": 2
  },
  {
    "question": "72. After returning from the recursive call PuzzleSolve(k-1, S, U), why is e added back to U?",
    "options": [
      "A. To test e in different positions for other permutations",
      "B. To maintain sorted order of U",
      "C. To avoid memory leaks"
    ],
    "correct_option_id": 0
  }
]
